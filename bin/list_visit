#!/usr/bin/env ruby
#
# == Synopsis 
#   A simple utility for listing visit details and scan acquistion
#   information from the terminal, either through freshly scanning
#   the filesystem or connecting to an imaging database and looking
#   up information through there (for Image Quality Checks, for 
#   example.
#
# == Examples
#
#   %> list_visit /Data/vtrak1/raw/ries.aware.visit1/awr001_7854_02102009
#
#   
#   list_visit
#
#   If no raw data directory is given, the current directory will be assumed.
#     %> cd /Data/vtrak1/raw/ries.aware.visit1/awr001_7854_02102009
#     %> list_visit
#
# == Usage 
#   %> list_visit <raw_data_directory>
# 
#   For help use: list_vist -h
#
# == Options
#   -h, --help          Displays help message
#
# == Author
#   Erik Kastman
#   WADRC Imaging Core
#

$:.unshift File.join(File.dirname(__FILE__),'..','lib')

require 'pathname'
require 'logger'
require 'metamri'

def run!
  options = parse_options
  
  # Default to scanning the current directory if no argument was given.
  raw_directory = ARGV[0] ||= Dir.pwd
  raw_directory = File.expand_path(raw_directory)
  
  list_visit raw_directory, options
  
end

def list_visit(raw_directory, options = {})
  unless $LOG
    $LOG = Logger.new(STDOUT)
    $LOG.level = options[:verbose] ? Logger::DEBUG : Logger::INFO
  end
  
  # First try to lookup Visit and Datasets through active_resource
  # Then fall back to scanning them fresh using the metamri classes.
  
  begin
    raise ScriptError, "Scaning filesystem directly..." if options[:force_scan]
    
    visit = VisitRawDataDirectoryResource.find(:first, :params => {:search => {:path => raw_directory}})
    
    raise IOError.new("Could not lookup visit using path.") unless visit
    raise IOError.new("Returned visit does not match path.") unless visit.path == raw_directory
  rescue ScriptError, IOError => e
    puts e
    visit = VisitRawDataDirectory.new(raw_directory)
    begin
      visit.scan(options)
    rescue IndexError => e
      $LOG.error "Are you sure #{raw_directory} is a valid raw visit directory?"
      raise e
    end
  end

  # Output a pretty version of the visit details.
  # Visit is Either a RawVisitDataDirectory or a RawVisitDataDirectoryResource,
  # and either should respond to to_s
  visit.to_s

end

def parse_options
  options = Hash.new
  parser = OptionParser.new do |opts|
    opts.banner = "Usage: #{File.basename(__FILE__)} [options] [directory]"

    opts.on('-s', '--scan', "Scan filesystem directly instead of checking database first.") do
      options[:force_scan] = true
    end
    
    opts.on('-v', '--verbose', "Be wordy.") do
      options[:verbose] = true
    end
    
    opts.on_tail('-h', '--help',          "Show this message")          { puts(parser); exit }
    opts.on_tail("If no directory is given, default is the current directory.")
    opts.on_tail("Example: #{File.basename(__FILE__)} pd006")

  end
  parser.parse!(ARGV)

  return options
end

if File.basename(__FILE__) == File.basename($PROGRAM_NAME)
  run!
end
